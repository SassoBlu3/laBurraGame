import { IGame } from "../interfaces/IGame.js";
import { IPlayer } from "../interfaces/IPlayer.js";
import { HumanPlayer } from "./HumanPlayer.js";
import { CPUPlayer } from "./CPUPlayer.js";
import { Card } from "./Card.js";
import { Deck } from "./Deck.js";

export class Game extends EventTarget implements IGame {
    players: IPlayer[] = [];
    deck: Deck;
    activeCard: Card | null = null;
    currentSuit: string = "";
    isHumanTurn: boolean = true; // Control de turno
    isFirstRound: boolean = true;
    humanPlayedCard: Card | null = null;
    cpuPlayedCard: Card | null = null;
    roundWinner: 'human' | 'cpu' | null = null;
    gameOver: boolean = false;
    gameWinner: 'human' | 'cpu' | null = null;

    constructor(playerNames: string[]) {
        super(); // Necesario al extender EventTarget
        this.deck = new Deck();
        this.deck.shuffle();

        this.players.push(new HumanPlayer("player-1", playerNames[0]));
        this.players.push(new CPUPlayer()); // Usar la clase correcta

        console.log("Jugadores iniciados:");
    }

    // Inicia la partida
    startGame(): void {
        console.log("INICIANDO PARTIDA");
        this.deck = new Deck(); // Reiniciar mazo
        this.deck.shuffle();

        // Limpiar manos
        this.players.forEach(p => p.hand = []);

        //limpiar estado de ronda
        this.isFirstRound = true;
        this.humanPlayedCard = null;
        this.cpuPlayedCard = null;
        this.roundWinner = null;
        this.gameOver = false;
        this.gameWinner = null;

        // Repartir 5 cartas
        for (let i = 0; i < 5; i++) {
            this.players.forEach(player => {
                const card = this.deck.dealCard();
                if (card) player.drawCard(card);
            });
        }

        // Carta inicial en mesa
        const initialCard = this.deck.dealCard();
        if (initialCard) {
            this.activeCard = initialCard;
            this.currentSuit = initialCard.suit;
            console.log(
                `Carta inicial: ${initialCard.mostrarNombreCompleto()} – Palo actual: ${this.currentSuit}`
            );
        }

        this.isHumanTurn = true; // Empieza el humano
    }

    // Jugar turno del humano
    playTurn(player: IPlayer, cardIndex: number): boolean {
        if (!this.isHumanTurn && player.isHuman) {
            console.warn("No es tu turno.");
            return false;
        }

        const hasSuit = player.canPlaySuit(this.currentSuit);
        if (!hasSuit) {
            console.log(`${player.name} no tiene ${this.currentSuit} y debe robar.`);
            this.handleDrawIfNecessary(player);
            return false; // No puede jugar debe robar antes
        }

        const cardToPlay = player.hand[cardIndex]; // Solo mirar, no quitar todavía
        if (!cardToPlay) return false;

        // Validación: Debe seguir el palo si tiene
        if (hasSuit && cardToPlay.suit !== this.currentSuit) {
            console.warn(
                `${player.name}: NO puedes jugar ${cardToPlay.suit}. Debes jugar ${this.currentSuit}.`
            );
            return false; // Jugada inválida
        }

        // Si pasa validación, jugamos la carta
        player.playCard(cardIndex); // Ahora sí la quitamos
        this.activeCard = cardToPlay;
        this.humanPlayedCard = cardToPlay; // Guardar carta jugada por humano

        console.log(`${player.name} juega: ${cardToPlay.mostrarNombreCompleto()}`); 


        // Cambio de turno
        this.isHumanTurn = false;

        // Programar turno CPU
        setTimeout(() => this.playCPUTurn(), 1500);

        return true;
    }

    private handleDrawForHuman(player: IPlayer): void {
        if (this.deck.cards.length === 0) {
            console.log("El mazo está vacío. No se pueden robar más cartas.");
            return;
        }

        const drawnCard = this.deck.dealCard();
        if (drawnCard) {
            player.drawCard(drawnCard);
            console.log(`${player.name} roba: ${drawnCard.mostrarNombreCompleto()}`);
            this.dispatchEvent(new CustomEvent('game-state-changed'));
        }
    }

    // Turno de la CPU
    private playCPUTurn(): void {
        const cpu = this.players.find(p => !p.isHuman) as CPUPlayer;
        if (!cpu) return;

        console.log("Turno de CPU...");

        // 1. Verificar si tiene carta del palo
        const hasSuit = cpu.canPlaySuit(this.currentSuit);

        if (hasSuit) {
            // Estrategia simple: jugar la primera válida
            const cardIndex = cpu.hand.findIndex(c => c.suit === this.currentSuit);
            if (cardIndex !== -1) {
                const card = cpu.playCard(cardIndex);
                if (card) {
                    this.activeCard = card;
                    this.cpuPlayedCard = card; // Guardar carta jugada por CPU
                   /* this.currentSuit = card.suit; // El palo sigue siendo el mismo, o cambia si es nueva ronda (reglas simples por ahora)*/
                    console.log(`CPU juega: ${card.mostrarNombreCompleto()}`);
                }
            }
        } else {
            // 2. Si no tiene, debe robar hasta encontrar o vaciar mazo
            this.handleDrawIfNecessary(cpu);
        }
        this.determineRoundWinner();
        this.isHumanTurn = this.roundWinner === 'human';
        this.dispatchEvent(new CustomEvent('game-state-changed'));



        // <CHANGE> El palo lo define la carta del ganador
        if (this.roundWinner === 'human' && this.humanPlayedCard) {
            this.currentSuit = this.humanPlayedCard.suit;
        } else if (this.roundWinner === 'cpu' && this.cpuPlayedCard) {
            this.currentSuit = this.cpuPlayedCard.suit;
        }

        // <CHANGE> Limpiar cartas jugadas para la próxima ronda (después de un delay)
            setTimeout(() => {
                this.humanPlayedCard = null;
                this.cpuPlayedCard = null;
                this.dispatchEvent(new CustomEvent('game-state-changed'));
            }, 2000);

            this.dispatchEvent(new CustomEvent('game-state-changed'));
        }


        // Volver turno al humano
        this.isHumanTurn = true;
        // Notificar a la UI (esto se haría idealmente con eventos, pero por ahora la UI sondeará o se actualizará tras el timeout)
        // Como no tenemos eventos, la UI en index.ts necesitará saber cuándo actualizarse. 
        // Por simplicidad, index.ts puede pasar un callback o sondear.
        // Vamos a añadir un callback simple si es necesario, o dejar que index.ts maneje el estado.
        // Notificar a la UI mediante un evento propio de la instancia Game
        this.dispatchEvent(new CustomEvent('game-state-changed'));
    }

    private determineRoundWinner(): void {
        if (this.humanPlayedCard && this.cpuPlayedCard) {
            return;
        }   

        const humanRank = this.humanPlayedCard.rank;
        const cpuRank = this.cpuPlayedCard.rank;

        console.log(`\n========== RONDA TERMINADA ==========`);
    console.log(`Tu carta: ${this.humanPlayedCard.mostrarNombreCompleto()} (Rank: ${humanRank})`);
    console.log(`CPU carta: ${this.cpuPlayedCard.mostrarNombreCompleto()} (Rank: ${cpuRank})`);

    // Ambas cartas son del mismo palo (porque es obligatorio)
    if (humanRank > cpuRank) {
        this.roundWinner = 'human';
        this.currentSuit = this.humanPlayedCard.suit; // El palo lo define la carta ganadora
        console.log(`GANADOR DE LA RONDA: ¡TÚ!`);
    } else {
        this.roundWinner = 'cpu';
        this.currentSuit = this.cpuPlayedCard.suit; // El palo lo define la carta ganadora
        console.log(`GANADOR DE LA RONDA: CPU`);
    }
   
    this.isFirstRound = false;

    setTimeout(() => {
        this.humanPlayedCard = null;
        this.cpuPlayedCard = null;
        this.dispatchEvent(new CustomEvent('game-state-changed'));
    }, 2000);
    
if (this.checkGameOver()) {
    return; // No continuar si el juego terminó
}

// (Removed duplicate checkGameOver implementation)
}

// Move getCardValue outside of determineRoundWinner to the class level
private getCardValue(card: Card): number {
    // Assign numeric values to card ranks
    const rankValues: { [key: string]: number } = {
        '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
        'J': 11, 'Q': 12, 'K': 13, 'A': 14
    };
    return rankValues[card.rank] || 0;
}

    private checkGameOver(): boolean {
        // Check if any player has no cards left
        for (const player of this.players) {
            if (player.hand.length === 0) {
                this.gameOver = true;
                this.gameWinner = player.isHuman ? 'human' : 'cpu';
                console.log(`${player.name} ganó la partida!`);
                this.dispatchEvent(new CustomEvent('game-over', { detail: { winner: this.gameWinner } }));
                return true;
            }
        }
        return false;
    }

    // Robar carta si no tiene del palo actual
    public handleDrawIfNecessary(player: IPlayer): void {
        console.log(`${player.name} no tiene ${this.currentSuit}. Debe robar.`);

        let drawnCard: Card | undefined;
        let found = false;

        // Límite de seguridad para no colgar
        let attempts = 0;
        while (!found && this.deck.cards.length > 0 && attempts < 50) {
            drawnCard = this.deck.dealCard();
            attempts++;

            if (drawnCard) {
                player.drawCard(drawnCard);
                console.log(`...roba: ${drawnCard.mostrarNombreCompleto()}`);

                if (drawnCard.suit === this.currentSuit) {
                    found = true;
                    // Jugarla inmediatamente
                    const index = player.hand.length - 1;
                    const played = player.playCard(index);
                    if (played) {
                        this.activeCard = played;
                        // this.currentSuit se mantiene
                        console.log(`¡${player.name} encontró y jugó: ${played.mostrarNombreCompleto()}`);
                    }
                }
            }
        }
    }
}
